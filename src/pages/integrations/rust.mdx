---
title: Rust
metaTitle: Learn How to Integrate and Configure Rust to Send Traces
pageTitle: OpenTelemetry Rust Configuration
subTitle: Ship traces from Rust to OpenSearch with OpenTelemetry
logo: rust
color: "#0f172a"
stackTypes: apm
description: Read Logit.io's numerous Rust APM source integrations from Logit.io documentation to learn how to send Rust data to Logit.io
tags: Rust, Systems Programming, Programming Language, Apm, Grpc, Http
---

Use Logstash and OpenTelemetry to easily send Rust logs and traces to your Logit.io Stack.

<Steps>
  ## Logs

  ### Install Integration
  
  <InstallIntegration/>
  
  ### Getting Started

  <Callout type="info">
    This sample app was created and tested with
    `rustc 1.88.0 (6b00bc388 2025-06-23)` and `cargo 1.88.0 (873a06493 2025-05-10)`
  </Callout>

  ### Rust Logging Example

  This example application demonstrates how to send logs from a Rust application to Logit.io via Logstash using TCP.

  We will use cargo to manage our dependencies and build the application. 
  The example uses the `log`, `env_logger`, `serde_json`, and `chrono` crates to handle logging, JSON formatting, and timestamps.

  In the folder you want to create the application, run the following command to create a new Rust project:

  ```bash
  cargo new rust_logstash_logger
  cd rust_logstash_logger
  ```

  Replace the contents of `Cargo.toml` and `src/main.rs` with the following code snippets. Make sure you are logged into your Logit.io account 
  as this will populate the Logstash host and port details that will receive the log.

  ```toml copy filename="Cargo.toml" showLineNumbers
  [package]
  name = "rust_logstash_logger"
  version = "0.1.0"
  edition = "2021"

  [dependencies]
  log = "0.4"
  env_logger = "0.10"
  serde_json = "1.0"
  chrono = "0.4"
  ```

  ```rust copy filename="main.rs" showLineNumbers /@logstash.host/ /"@logstash.port:strip_quotes"/
  use chrono::Utc;
  use log::{info};
  use serde_json::json;
  use std::io::Write;
  use std::net::TcpStream;

  fn send_to_logstash(json_log: String) {
      if let Ok(mut stream) = TcpStream::connect("@logstash.host:@logstash.port") {
          let _ = stream.write_all(json_log.as_bytes());
          let _ = stream.write_all(b"\n");
      } else {
          eprintln!("Could not connect to Logstash");
      }
  }

  fn main() {
      env_logger::init();

      let log_entry = json!({
          "timestamp": Utc::now().to_rfc3339(),
          "level": "INFO",
          "message": "Hello from Rust!",
          "application": "rust_logstash_logger"
      });

      send_to_logstash(log_entry.to_string());

      // Also log to stdout for visibility
      info!("Log sent to Logstash");
  }
  ```

  To run the application, execute the following command in your terminal:

  ```bash copy
  cargo run
  ```

  ### Launch OpenSearch Dashboards to View Your Data

  <LaunchVisualizer type="logs" />

</Steps>

  Get started quickly with OpenTelemetry for Rust using our configuration guide on how to easily ship Rust traces to your hosted OpenSearch.
<Steps>
  ## APM

  ### Install Integration
  
  <InstallIntegration/>
  
  ### Getting Started

  <Tabs items={["HTTPS", "gRPC"]}>
  
  <Tab>
    You can get help Getting Started with OpenTelemetry for Rust by referring to the 
    [official documentation](https://opentelemetry.io/docs/instrumentation/rust/getting-started/). 

    This example uses the snippet found [here](https://docs.rs/opentelemetry-otlp/latest/opentelemetry_otlp/) as its basis.

    ```rust copy showLineNumbers /@opentelemetry.base64encodedAuthString/ /@opentelemetry.endpointAddress/ /@opentelemetry.grpcPort/
    use opentelemetry_api::{KeyValue, trace::Tracer};
    use opentelemetry_sdk::{trace::{self, RandomIdGenerator, Sampler}, Resource};
    use opentelemetry_sdk::util::tokio_interval_stream;
    use opentelemetry_otlp::{Protocol, WithExportConfig, ExportConfig};
    use std::time::Duration;
    use tonic::metadata::*;

    fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync + 'static>> {
        let mut map = MetadataMap::with_capacity(1);

        map.insert("authorization", "Basic @opentelemetry.base64encodedAuthString".parse().unwrap());

        let tracer = opentelemetry_otlp::new_pipeline()
            .tracing()
            .with_exporter(
                opentelemetry_otlp::new_exporter()
                .tonic()
                .with_endpoint("https://@opentelemetry.endpointAddress:@opentelemetry.httpsPort")
                .with_metadata(map)
            )
            // The trace config below should be amended to your requirements
            .with_trace_config(
                trace::config()
                    .with_sampler(Sampler::AlwaysOn)
                    .with_id_generator(RandomIdGenerator::default())
                    .with_max_events_per_span(64)
                    .with_max_attributes_per_span(16)
                    .with_max_events_per_span(16)
                    .with_resource(Resource::new(vec![KeyValue::new("service.name", "example")])),
            )
            .install_batch(opentelemetry::runtime::Tokio)?;

        let export_config = ExportConfig {
            endpoint: "https://@opentelemetry.endpointAddress:@opentelemetry.httpsPort".to_string(),
            protocol: Protocol::http/protobuf
        };

        tracer.in_span("doing_work", |cx| {
            // Traced app logic here...
        });

        Ok(())
    }
    ```

    For more information about exporter configuration with Rust please refer to the 
    [official documentation](https://opentelemetry.io/docs/instrumentation/rust/exporters/).
  </Tab>

  <Tab>
    You can get help Getting Started with OpenTelemetry for Rust by referring to the 
    [official documentation](https://opentelemetry.io/docs/instrumentation/rust/getting-started/). 

    This example uses the snippet found [here](https://docs.rs/opentelemetry-otlp/latest/opentelemetry_otlp/) as its basis.

    ```rust copy showLineNumbers /@opentelemetry.base64encodedAuthString/ /@opentelemetry.endpointAddress/ /@opentelemetry.grpcPort/
    use opentelemetry_api::{KeyValue, trace::Tracer};
    use opentelemetry_sdk::{trace::{self, RandomIdGenerator, Sampler}, Resource};
    use opentelemetry_sdk::util::tokio_interval_stream;
    use opentelemetry_otlp::{Protocol, WithExportConfig, ExportConfig};
    use std::time::Duration;
    use tonic::metadata::*;

    fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync + 'static>> {
        let mut map = MetadataMap::with_capacity(1);

        map.insert("authorization", "Basic @opentelemetry.base64encodedAuthString".parse().unwrap());

        let tracer = opentelemetry_otlp::new_pipeline()
            .tracing()
            .with_exporter(
                opentelemetry_otlp::new_exporter()
                .tonic()
                .with_endpoint("https://@opentelemetry.endpointAddress:@opentelemetry.grpcPort")
                .with_metadata(map)
            )
            // The trace config below should be amended to your requirements
            .with_trace_config(
                trace::config()
                    .with_sampler(Sampler::AlwaysOn)
                    .with_id_generator(RandomIdGenerator::default())
                    .with_max_events_per_span(64)
                    .with_max_attributes_per_span(16)
                    .with_max_events_per_span(16)
                    .with_resource(Resource::new(vec![KeyValue::new("service.name", "example")])),
            )
            .install_batch(opentelemetry::runtime::Tokio)?;

        let export_config = ExportConfig {
            endpoint: "https://@opentelemetry.endpointAddress:@opentelemetry.grpcPort".to_string(),
            protocol: Protocol::Grpc
        };

        tracer.in_span("doing_work", |cx| {
            // Traced app logic here...
        });

        Ok(())
    }
    ```

    For more information about exporter configuration with Rust please refer to the 
    [official documentation](https://opentelemetry.io/docs/instrumentation/rust/exporters/).
  </Tab>

  </Tabs>

  ### Launch Jaeger to View Your Data

  <LaunchVisualizer type="apm" />

  ### How to diagnose no data in Stack

  <DiagnoseNoData />
</Steps>